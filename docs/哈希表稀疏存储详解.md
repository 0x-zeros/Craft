# Craft游戏哈希表稀疏存储详解

## 稀疏数据存储的挑战

### **传统数组存储的问题**
如果使用传统的3D数组存储一个32x32x256的区块：
```c
// 传统方式 - 浪费大量内存
int blocks[32][256][32];  // 需要 32*256*32*4 = 1MB 内存
```

**问题**：
- 大部分位置是空气（EMPTY = 0）
- 实际有方块的位置很少
- 内存使用效率极低

### **稀疏数据的特点**
在Minecraft风格的游戏中：
- 地下大部分是实心方块
- 地面以上大部分是空气
- **有效数据只占总空间的10-30%**

## 哈希表解决方案

### **Map数据结构设计**

```c
// 地图结构 - 使用哈希表存储稀疏的3D方块数据
typedef struct {
    int dx, dy, dz;      // 区块偏移坐标
    unsigned int mask;   // 哈希表掩码（大小-1）
    unsigned int size;   // 已使用条目数
    MapEntry *data;      // 哈希表数据
} Map;

// 地图条目 - 存储单个方块的位置和类型
typedef union {
    unsigned int value;  // 用作哈希值判断
    struct {
        unsigned char x; // 相对X坐标 (0-255)
        unsigned char y; // 相对Y坐标 (0-255)
        unsigned char z; // 相对Z坐标 (0-255)
        char w;          // 方块类型
    } e;
} MapEntry;
```

### **哈希表的核心原理**

#### **1. 哈希函数计算**
```c
int hash(int x, int y, int z) {
    x = hash_int(x);  // 对每个坐标分别哈希
    y = hash_int(y);
    z = hash_int(z);
    return x ^ y ^ z; // XOR组合结果
}

// 计算哈希表索引
unsigned int index = hash(x, y, z) & map->mask;  // & 0x7fff
```

#### **2. 存储过程 (map_set)**
```c
int map_set(Map *map, int x, int y, int z, int w) {
    // 1. 计算哈希索引
    unsigned int index = hash(x, y, z) & map->mask;
    
    // 2. 转换为相对坐标
    x -= map->dx;
    y -= map->dy; 
    z -= map->dz;
    
    // 3. 线性探测处理冲突
    MapEntry *entry = map->data + index;
    while (!EMPTY_ENTRY(entry)) {
        if (entry->e.x == x && entry->e.y == y && entry->e.z == z) {
            // 找到已存在的位置，更新方块类型
            entry->e.w = w;
            return 1;
        }
        index = (index + 1) & map->mask;  // 线性探测下一个位置
        entry = map->data + index;
    }
    
    // 4. 找到空位置，插入新数据
    entry->e.x = x;
    entry->e.y = y;
    entry->e.z = z;
    entry->e.w = w;
    map->size++;
    
    // 5. 负载因子检查，防止哈希冲突过多
    if (map->size * 2 > map->mask) {
        map_grow(map);  // 扩展哈希表
    }
}
```

#### **3. 查询过程 (map_get)**
```c
int map_get(Map *map, int x, int y, int z) {
    // 1. 计算哈希索引
    unsigned int index = hash(x, y, z) & map->mask;
    
    // 2. 转换为相对坐标
    x -= map->dx;
    y -= map->dy;
    z -= map->dz;
    
    // 3. 线性探测查找
    MapEntry *entry = map->data + index;
    while (!EMPTY_ENTRY(entry)) {
        if (entry->e.x == x && entry->e.y == y && entry->e.z == z) {
            return entry->e.w;  // 找到，返回方块类型
        }
        index = (index + 1) & map->mask;
        entry = map->data + index;
    }
    return 0;  // 未找到，返回空气
}
```

## 关键优化技术

### **1. 相对坐标系统**
```c
// 区块初始化时设置偏移
int dx = p * CHUNK_SIZE - 1;  // 区块偏移
int dy = 0;
int dz = q * CHUNK_SIZE - 1;
map_alloc(block_map, dx, dy, dz, 0x7fff);
```

**好处**：
- 将世界坐标转换为相对坐标（0-255范围）
- 只用1字节存储每个坐标分量
- 节省内存空间

### **2. 联合体优化**
```c
typedef union {
    unsigned int value;  // 4字节整体值
    struct {
        unsigned char x; // 1字节
        unsigned char y; // 1字节  
        unsigned char z; // 1字节
        char w;          // 1字节
    } e;
} MapEntry;
```

**好处**：
- `EMPTY_ENTRY(entry)`检查只需比较`entry->value == 0`
- 比分别检查4个字段更高效

### **3. 动态扩展**
```c
void map_grow(Map *map) {
    // 哈希表大小翻倍
    new_map.mask = (map->mask << 1) | 1;  // 0x7fff -> 0xffff
    
    // 重新哈希所有数据
    MAP_FOR_EACH(map, ex, ey, ez, ew) {
        map_set(&new_map, ex, ey, ez, ew);
    } END_MAP_FOR_EACH;
}
```

**负载因子控制**：
- 当`size * 2 > mask`时触发扩展
- 保持负载因子在50%以下
- 减少哈希冲突，保证性能

### **4. 位运算优化**
```c
// 使用位运算代替取模运算
index = hash(x, y, z) & map->mask;  // 等价于 hash % (mask+1)
index = (index + 1) & map->mask;    // 线性探测
```

**条件**：`mask`必须是2的幂减1（如0x7fff）

## 性能分析

### **内存使用对比**
| 存储方式 | 内存使用 | 适用场景 |
|---------|---------|----------|
| 3D数组 | 1MB固定 | 密集数据 |
| 哈希表 | 8字节×实际方块数 | 稀疏数据 |

**实际例子**：
- 传统数组：262,144个位置 × 4字节 = 1MB
- 哈希表：5,000个方块 × 8字节 = 40KB
- **节省96%的内存**

### **时间复杂度**
| 操作 | 平均情况 | 最坏情况 |
|------|---------|----------|
| 插入 | O(1) | O(n) |
| 查询 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

## 实际应用示例

### **区块数据遍历**
```c
// 遍历区块中的所有非空方块
MAP_FOR_EACH(&chunk->map, x, y, z, block_type) {
    if (is_plant(block_type)) {
        // 处理植物
    } else {
        // 处理普通方块
    }
} END_MAP_FOR_EACH;
```

### **边界检查优化**
```c
// 只检查相对坐标范围，避免额外计算
if (x < 0 || x > 255) return 0;
if (y < 0 || y > 255) return 0;
if (z < 0 || z > 255) return 0;
```

## 掩码值详解

### **0x7fff 和 0xf 的含义**

在`map_alloc`函数中使用的掩码值：

```c
void init_chunk(Chunk *chunk, int p, int q) {
    // ...
    map_alloc(block_map, dx, dy, dz, 0x7fff); // 方块数据哈希表
    map_alloc(light_map, dx, dy, dz, 0xf);    // 光照数据哈希表
}
```

#### **0x7fff (32767)**
- **二进制**：`0111 1111 1111 1111`
- **用途**：方块数据哈希表掩码
- **大小**：32,768个槽位（0x7fff + 1）
- **原因**：方块数据量大，需要更多存储空间

#### **0xf (15)**
- **二进制**：`0000 1111`
- **用途**：光照数据哈希表掩码
- **大小**：16个槽位（0xf + 1）
- **原因**：光照数据相对较少，使用小容量哈希表

### **掩码设计原理**
```c
// 掩码必须是 2^n - 1 的形式
0x7fff = 2^15 - 1 = 32767  // 15位全1
0xf    = 2^4  - 1 = 15     // 4位全1

// 这样设计的好处：
index = hash & mask;  // 等价于 hash % (mask + 1)
// 位运算比取模运算更快
```

## 总结

Craft游戏的哈希表稀疏存储方案具有以下优势：

1. **内存高效**：只存储非空方块，节省90%+内存
2. **访问快速**：O(1)平均时间复杂度
3. **动态扩展**：根据负载自动调整大小
4. **坐标优化**：相对坐标系统减少存储空间
5. **冲突处理**：线性探测简单高效
6. **掩码优化**：使用位运算代替取模运算

这种设计完美适配了体素游戏中**大量空气方块**的特点，是现代体素游戏引擎的标准做法。

---

*文档创建时间：2024年*
*基于Craft游戏源码分析*
