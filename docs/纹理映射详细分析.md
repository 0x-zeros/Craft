# 纹理映射详细分析

## 纹理映射完整流程

### 1. **纹理图集结构 (texture.png)**

根据你提供的纹理图片，这是一个 **16x16 的纹理图集**，包含 256 个纹理单元：

```
纹理图集布局：
[  0] [  1] [  2] [  3] ... [ 15]  第1行
[ 16] [ 17] [ 18] [ 19] ... [ 31]  第2行
[ 32] [ 33] [ 34] [ 35] ... [ 47]  第3行
[ 48] [ 49] [ 50] [ 51] ... [ 63]  第4行
...
[240] [241] [242] [243] ... [255] 第16行
```

### 2. **方块类型到纹理ID的映射**

```c
const int blocks[256][6] = {
    // w => (left, right, top, bottom, front, back) tiles
    {0, 0, 0, 0, 0, 0}, // 0 - empty
    {16, 16, 32, 0, 16, 16}, // 1 - grass
    {1, 1, 1, 1, 1, 1}, // 2 - sand
    {2, 2, 2, 2, 2, 2}, // 3 - stone
    {3, 3, 3, 3, 3, 3}, // 4 - brick
    {20, 20, 36, 4, 20, 20}, // 5 - wood
```

**具体分析草方块 (GRASS = 1)：**
- `blocks[1] = {16, 16, 32, 0, 16, 16}`
- 左面：纹理ID 16 (第2行第1个)
- 右面：纹理ID 16 (第2行第1个)  
- 顶面：纹理ID 32 (第3行第1个)
- 底面：纹理ID 0 (第1行第1个)
- 前面：纹理ID 16 (第2行第1个)
- 后面：纹理ID 16 (第2行第1个)

### 3. **纹理ID到UV坐标的转换**

在 `make_cube_faces` 函数中：

```c
float s = 0.0625;           // 1/16，每个纹理单元的大小
float a = 0 + 1 / 2048.0;   // 左上角偏移
float b = s - 1 / 2048.0;   // 右下角偏移
```

```c
float du = (tiles[i] % 16) * s;  // U坐标偏移
float dv = (tiles[i] / 16) * s;  // V坐标偏移
```

**纹理ID到UV坐标计算：**

```c
// 对于纹理ID = 32 (草的顶面)
int tile_id = 32;
float du = (32 % 16) * 0.0625 = 0 * 0.0625 = 0.0    // 第3行第1列
float dv = (32 / 16) * 0.0625 = 2 * 0.0625 = 0.125  // Y偏移

// 对于纹理ID = 16 (草的侧面)  
int tile_id = 16;
float du = (16 % 16) * 0.0625 = 0 * 0.0625 = 0.0    // 第2行第1列
float dv = (16 / 16) * 0.0625 = 1 * 0.0625 = 0.0625 // Y偏移
```

### 4. **最终UV坐标生成**

```c
*(d++) = du + (uvs[i][j][0] ? b : a);  // 最终U坐标
*(d++) = dv + (uvs[i][j][1] ? b : a);  // 最终V坐标
```

**完整UV坐标计算流程：**

1. **基础UV坐标模板**：
   ```c
   static const float uvs[6][4][2] = {
       {{0, 0}, {1, 0}, {0, 1}, {1, 1}}, // 左面
       {{1, 0}, {0, 0}, {1, 1}, {0, 1}}, // 右面
       // ... 其他面
   };
   ```

2. **纹理偏移计算**：
   ```c
   float du = (tile_id % 16) * 0.0625;  // 水平偏移
   float dv = (tile_id / 16) * 0.0625;  // 垂直偏移
   ```

3. **最终坐标**：
   ```c
   final_u = du + (uvs[face][vertex][0] ? 0.0605 : 0.0005);
   final_v = dv + (uvs[face][vertex][1] ? 0.0605 : 0.0005);
   ```

### 5. **实际示例：草方块顶面**

```
方块类型：GRASS (ID = 1)
面：顶面 (index = 2)
纹理ID：blocks[1][2] = 32

计算过程：
1. du = (32 % 16) * 0.0625 = 0.0
2. dv = (32 / 16) * 0.0625 = 0.125
3. 四个顶点的UV坐标：
   - 顶点0: (0.0005, 0.1255)    // 左上角
   - 顶点1: (0.0005, 0.1875)    // 左下角  
   - 顶点2: (0.0605, 0.1255)    // 右上角
   - 顶点3: (0.0605, 0.1875)    // 右下角
```

### 6. **边界处理**

```c
float a = 0 + 1 / 2048.0;      // 0.0005 - 避免纹理边界问题
float b = s - 1 / 2048.0;      // 0.0605 - 避免纹理渗透
```

这个小偏移防止了：
- **纹理边界渗透**：避免采样到相邻纹理
- **浮点精度问题**：确保UV坐标精确落在纹理内部

## 完整数据流

```
方块类型ID → blocks数组 → 纹理ID → UV坐标计算 → 顶点数据 → GPU渲染
     ↓            ↓          ↓           ↓            ↓         ↓
    GRASS    →   32      →  0.125    →  0.1255   →   顶点    →  显示
    (1)         (顶面)     (V偏移)     (最终V)      缓冲区     纹理
```

这个设计非常巧妙，通过一张纹理图集和简单的数学计算，实现了灵活的方块纹理系统，支持每个方块6个面使用不同纹理，同时保持了高效的GPU渲染性能。
